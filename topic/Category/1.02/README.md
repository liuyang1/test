1. 用你最喜欢的语言，定义一个高阶函数（或函数对象）memoize。这个函数接受一个纯函数 f，返回一个行为与 f 近乎相同的函数 g，但是 g 只是第一次被调用时与 f 的功能相同，然后它在内部将结果存储了起来，后续再用同样的参数调用它，它只返回自己存储的那个结果。你可以通过观察 f 与 g 的运行效率来区分它们。例如，让 f 是一个需要耗费挺长时间才能完成计算的函数，这样，当第一次调用 g 的时候，它会运行的很慢，但是用同样的参数对 g 再次调用，则可以立即得到结果。

```
我们已经有Scheme,Haskell,Python的版本了.
```

2. 标准库中用于生成随机数的函数，能够被 memoize 么？

```
显然不行啊, 因为内部要更新seed. 如果memoize,就不能或者不会对应的更新seed了.
```

3. 大多数随机数生成器都能够用一个种子进行初始化。请实现一个能够接受种子的函数，这个函数可将种子转交给随机数生成器，然后返回所得结果。这个函数能被 memoize 么？

```
如果随机数生成器,每次都接受上一次的结果作为seed,那么就可以.
```

4. 下面的 C++ 函数，哪一个是纯的？试着去 memoize 它们，然后多次调用后看看会发生什么：能被 memoize 还是不能。

(1) 文中的阶乘函数。

```
是的, 可以.
```

(2) std::getchar()

```
不行.
```

(3)

    bool f() {
        std::cout << "Hello!" << std::endl;
        return true;
    }

```
不行, 这会导致副作用输出函数,不会被执行.
```

(4)

    int f(int x)
    {
        static int y = 0;
        y += x;
        return y;
    }

    ```
    不行, 内部状态y没有被更新
    ```

5. 从 Bool 到 Bool 的函数有多少中？你可以将它们都实现出来么？

```
f0 = id

f1 = not

f2 _ = True

f3 _ = False
```

6. 将 Void，()（unit）以及 Bool 作为对象，将与这些类型相关的所有函数作为箭头，你能画出一个范畴么？用函数名来标注箭头。

```
Void -> Bool 但是不能被调用
() -> Bool   没有输出,始终返回一个值
Bool -> ()   从Bool到()的unit函数
Void -> ()   也是存在的,一样不能调用


() <--->  Bool
^           ^
|           |
+--- Void --+

是一个范畴
```
