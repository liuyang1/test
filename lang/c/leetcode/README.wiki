= Leetcode =
Leetcode is a platform for coding interviews. Practice on this platform for
interviews.

    - Basic exercise
    - Corner case
        - Overflow
        - Empty array, empty linked list
    - Practice NOT using IDE, compiler, editor to finish problem

Progress:: 84 / 307

= review =
== basic ==
* 1. Two Sum
Given an array of integers, find two numbers such that they add up to a
specific target number.

Requirement: complexity O(n * log(n))

    - quicksort this array with memorize origin index( as we must return origin
    index)
    - cursor moving, one from left, one from right.
        - when sum is less, moving left cursor
        - when sum is greater, moving right cursor

NOTICE: qsort return list with ascending sequence, comparing function return
1 when A GREATER than B.

* 2. Add Two Numbers
linked-list represent numbers, one node contains a single digit. Digits are
stored in reverse order.

    - Adding number with manually adding digit and carry

* 38. Count and Say

    - easy, one detail, is only occur 1, 2 or 3 in string.

* 48. Rotate Image

    - clockwise assign value in grid

* 67. Add Binary strings, return sum

    - remove extra leading zero, but keep it if only one zero

* 238. Product of Array Except Self

    - accumulate

* 318. Maximum Product of Word Length

    - easy, remember using statistic map array

=== range sum ===
* 303. Range Sum Query (Immutable)
* 304. Range Sum Query 2D (Immutable)

    - Accmulate
> This accumulate solution also works to find median of range

* 307. Range Sum Query (Mutable)

    - Tree

| struct | update    | range sum |
| array  | O(1)      | O(m)      |
| accum  | O(n)      | O(1)      |
| Tree   | O(log(n)) | O(log(n)) |

== math ==
=== Basic ===
* 50. Pow

    binary recursion

* 168. Excel Sheet Column Title

    Remember minus one first as it's biased.

* 171. Excel Sheet Column Number

This problem look like 26-base number, but must notice A is not zero, but ONE.

* 169. Majority element in array

    Moore's Voting Algorithm! Very cool idea!

* 229. Majority element in array II

Support find all element that appear more than [n / K] times.

    Misra-Geries Algorithm, inspired by Moore's Voting Algorithm.

* 258. Digit Root
Repeatedly add all digits until result has only one digit.

    All number roundly map to [1, 9] , except zero map to zero. Then get
    beautiful function.

* 268. Missing One Number
One number not in [0 .. n] array, find it.

    Just sum then get it. However, this problem should consider overflow.

* 326. Power of Three

    Simple but really awesome!
=== Probability ===
* 169. Majority element in array

    Just guess any random one, then check it is majority. As Probability, in
    average, only need guess twice, so this complexity is O(n)
    We even can avoid re-guess wrong one, so guess less times.

=== Combination ===
* 46. Permutations

    Generator permutations

* 62. Unique paths

m * n grid, from left-upper corner move to bottom-right corner, How many
possible unique paths?

    Just `combination(m + n - 2, m - 1)`.
    Mind not overflow when calculate combination

* 77. Combinations

    Generator combinations

=== Computational Geometry ===
* 223. Find total area covered by two rectangles which may overlap.

    Simply start calc on 1-D line, then easily and elegant extend to 2-D

=== Bitwise operation ===
* 191. Number of 1 bits.

    n &= (n - 1)

== struct ==
=== array ===
=== linked list ===
* 125. Valid Palindrome

    - checking is palindrome string, only consider alphanumeric char and
    ignore cases

* 234. Palindrome Linked List

    - reverse half end linked list, then compare, then reverse it back

* 141. Linked List Cycle
* 141. Linked List Cycle II

    - This is classical problem. Just use fast / slow pointer
    - Moveing fowarder A step to get cycle begin node

* 206. Reverse Linked List
* 328. Odd Even Linked List
=== Tree ===
==== Traverse on Tree ====
* 94. Inorder Traverse on Tree

    - use recursion and realloc as need return as array

* 100. Same Tree
* 112. Path Sum

    - Traverse on tree

* 144. Binary Tree Preorder Traversal

    - use stack to iteratively on tree

* Level Traverse on Tree
NOT problem, but serial/deserial tree in OJ, implement one for local test

    - use queue

* 116, 117. Sibling of Tree

    - Add sibling, this is not complex, familar with pointer is enough

* 173. Binary Search Tree Iterator

    - implement an iterator on Tree use stack, DFS and Left node first

== algorithm ==
=== binary search ===
- 35. Search Insert Position

    binary search, and handle not find case

- 69. Sqrt

    binary search on [1, 65535] as limit of INT range

- 319. Blub switcher

    find regular pattern first, increase with sqrt(n)
    implement binary search sqrt as #69
=== sort ===
- 088. Merge sorted array locally

    ~~Just copy data to end first~~
    merge from tail, as data is consuming

== Parser / Compiler ==
- 224. Basic calculate

    - recursion from tail, so calculate from head
    - parentheses is key problem
    - avoid duplicate string, but calculate in-place
= Issues =
== runtime error, but local run good ==
runtime checking different, may read or write out of bound, but local don't
warning this, double check it.

== memory leak ==
Online Judge system won't check memory leak, fix them all with `cppcheck`.
