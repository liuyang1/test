(define (make-tree entry left right)
  (list entry left right))

(define (union set0 set1)
  (define (make-tree-5 root0 root1 left mid right)
    (display root0)
    (display " next ")
    (display root1)
    (display " next ")
    (display left)
    (display " next ")
    (display mid)
    (display " next ")
    (display right)
    (newline)
    (make-tree root1
               (make-tree root0 left mid)
               right))
  (cond  ((null? set0) set1)
         ((null? set1) set0)
         ((= (car set0) (car set1))
         (make-tree (car set0)
                    (union (cadr set0) (cadr set1))
                    (union (caddr (set0)) (caddr set1))))
        ((< (car set0) (car set1))
         (make-tree-5 (car set0) (car set1) (cadr set0)
                      (union (caddr set0) (cadr set1) )
                      (caddr set1)))
        ((> (car set0) (car set1)) (union set1 set0))))

(define (list->tree lst)
(define (partial-tree elts n)
  (if (= n 0) (cons '() elts)
    (let ((left-size (quotient (- n 1) 2)))
     (let ((left-result (partial-tree elts left-size)))
      (let ((left-tree (car left-result))
            (non-left-elts (cdr left-result))
            (right-size (- n (+ left-size 1))))
        (let ((this-entry (car non-left-elts))
              (right-result (partial-tree (cdr non-left-elts) right-size)))
          (let ((right-tree (car right-result))
                (remaining-elts (cdr right-result)))
            (cons (make-tree this-entry left-tree right-tree)
                  remaining-elts))))))))
  (car (partial-tree lst (length lst))))

(define *obj* (list->tree '(1 3 5 7 9 11)))
(displayln *obj*)
(define *obj1* (list->tree '(1 4 7 9 13)))
(displayln *obj1*)
(displayln (union *obj* *obj1*))
