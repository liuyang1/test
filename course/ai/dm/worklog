2011-12-04 23:20:31
	user parse finish!
2011-12-05 12:21:52
	userset parse add,
	action & actionset add.
2011-12-05 13:46:55
	userset parse finish!
2011-12-05 14:57:57
	actionset finish!
	actionset select method finish!
[TODO]
	matchInfoBase
	matchInfoSmart
	matchAvatar
	matching
	similarity
	similaInfo
	similaAvatar
[PROBLEM]
	匹配二者的信息,
	1,基本要求的匹配,
		即二者的相互要求要一致(B符合A的match需求,A不完全符合B的match要求)
		这个基本要求的匹配,采用模糊的方法
		也就是的不会完全拒绝不符合要求的人,而是取一个较低的匹配度而已
	2,智能匹配
		比如有可能对学历没有要求,那么也要最好匹配相同学历的人.
		对与工作地点,明显必须选择相同工作地点的人.
	3,相貌匹配
		这个是很复杂的了,因为完全没有数据,只能根据训练数据的表现来进行推测.
	4,匹配度
		结合上面三点给出一个匹配值
	
	判断二者的相似程度
	5,相似性
		即A,B(同性)的属性相似情况
		综合信息相似和相貌相似两个特点
	6,信息相似
	7,相貌相似

	程序的总体考虑
	基于相似的人有相同的选择,相同选择的人是相似的.进行迭代
2011-12-05 15:39:14
	framework of training is ok!
2011-12-07 00:50:21
	matchbase is ok!
2011-12-07 08:48:33
[OVER]
	Stat结构,进行信息统计
	typedef map<template T,int>		Stat;
	或者直接
	typedef map<int,int>			Stat;
	统计基本的信息,如年龄分布,年龄要求分布,身高分布,身高要求分布
	婚姻状况分布,婚姻状况要求分布,教育情况分布,教育要求分布
[PROBLEM]
	项目的内容还是很复杂的,完成基本的结构就需要很多东西要做.
	而高级的算法部分,自己的理解还非常的不成熟.
	比如如何对用户进行聚类,直接去判断相似是不是就是方向不对的.
	各个属性的权值如何划分,或者怎么样的计算相似度
2011-12-14 21:48:24
	上周的东西终于扫清了,这周一定要把dm完成!
2011-12-16 10:13:56
	注意力集中来干活
[DAILY_TODO]
	Elo算法的实现,暂时方案是:
	EloRating -> rank -> Expect Wining Probablity
	user's choice -> rank -> Winning Probaliblity(Scorce)
	both to check EloRating
[PROBLEM]
	typedef map<int,int> BaseStat;
	这个map结构计算速率太过于慢了,
	因为map为每个结构都开辟空间,数据集在10^5数量级,完全无法接受
	1000/min,200k的量级就需要200min,约为3+hour
	这还仅仅是统计身高分布这样简单的运算!
	bs[us.m_Data[i].getHeight()]++;
	如上为程序遍历的单位操作,仅仅是一个寻址[],一次内联函数调用getheight(),一次寻址[],一次++
	看来只能怪map这个数据结构了,事实上map的key的添加并不频繁,
	map的key的计算过于复杂了?
	幸好的是,程序占用的内存并没有增加.
	但是为了存储200k量级的数据就花费了140M的内存
	如果添加上另外的200k数据和大量的训练数据,这整个就使得机器没有办法运转起来了!
2011-12-16 14:18:16
	可能的问题在于复制传值上,因为每次都会复制内容UserSet过去,这毫无疑问是非常复杂的.
	改用const指针传值,这样应该快很多吧?
	修改后,速度基本相当,内存占用减少到70M,
	改用指针后,速度快了千倍不止啊,瞬间完成!
2011-12-16 14:49:38
[BUGFIX]
	部分数据不合法,删除
[FIX!BUG]
	-1208852480 : 344847
	不知道这个统计信息是如何冒出来的啊
	FIX!
	UserSet的map结构误用了[],导致添加了多余的映射导致的
	添加数据校验功能,对于不合适的数据,删除,不添加见数据库
2011-12-16 18:06:59
	现在问题的关键就在于multiELo的算法问题
	简而言之,就是每个人的得分是一个logistic分布,但是中心值不同,就是elo值,
	在两人的时候,A取胜的概率P(Ra>Rb)=1/(1+10^((Ra-Rb)/400))
	显然,这是根据条件概率P(Ra>Rb)=P(Ra>R|Rb=R)=...积分的来的,
	那么多人的计算呢?
	这里首先按照一种方法进行计算,
	那就是P(Ra,rank(Ra)=n)=log(1+i)/sum(log(1+i))
	这种方法是直接根据ndcg的排序得到的,
	[没有任何数学基础]
	暂时为了完成程序周期使用
2011-12-16 18:52:09
	终于完成一个版本了啊!
	不过后续的测试工作就要展开了
[TODO]
	完善训练模块
	添加对测试集进行测试的模块
[FIX!BUG]
	init test file failed!
	because init it using aciton module
	FIX!
	TestSet继承自ActionSet,并且修改了初始化的方法
[?BUG]
	对acitonSet有没有clear的必要?好像没有
2011-12-16 19:36:51
[BUG]
	申请内存失败,也就是完全载入的时候
	使用C++风格的new,delete还是不行
	想自己编写一个alloc呢,发现完全不行.简单的使用一块内存空间,然后通过移动指针
	进行malloc和free操作.
	最大的问题就是多个操作进行的时候,会有一个很大的bug
	试想alloc(p1),alloc(p2),free(p1),free(p2),就和{,}不匹配一样,
	这里的alloc和free一旦不匹配,就会有错误
	所以这里有一个内存分片的问题..
[PROBLEM]
	利用固定存储空间的方法,或许可以解决问题.
	但是ActionSet的扫描方法,实在是过于缓慢,因为其vector结构就不适应与这样的计算
	速度大概为2k/min,实际用户数大概为203K+350K,也就是550K
	因此需要处理时间大概为4Hour,完全不能接受
	看来我本就应该把数据集放到数据库里面去!
	就是因为自己不熟,或者做简陋的系统,习惯了,才导致了这个恶劣的结果!

	这个代码写的,真的很失败!
	封装不够,而且,效率如此低下,居然想测试都不行
2011-12-18 00:12:31
	对ver0.1封板
	这个版本里面actionSet采用的还是vector结构,下面要为其选择一个合适的数据结构来进行后续的存储
	可能为set或者multimap结构
	明天再做吧
	或者考虑使用数据库支持
	或者考虑每次从文件读取,这样的速度估计还是接受不了的
2011-12-18 01:25:21
	multimap修正完毕,等待明天的测试
	修正过程并没有自己想象的复杂
2011-12-18 08:57:16
	测试结束,需要4min,这个是可以接受的,看来一个合适的数据结构真的非常重要.
	测试中发现,有的id,会进行高达数万次的rec,这是非常不合理的.应该考虑把这些数据去掉.
	剔除频次非常高的数据,时间控制在1min内,现在好了.可以充分考虑下一步工作了
	奶奶的,超过10000的数据加起来大约为1M,也就是占据train数据的1/8,这也太多了吧
	经测试有效数据,集中在rec频率低于2000上,超过的只有一组,因此几乎没有意义
	限定超过2000的数据集丢弃
2011-12-18 09:48:22
[Fix!bug]
	action的值为0,1,2,映射的得分为0,1,3,之前action值错误为1,2,3导致问题
	不过这样的话,得分总和就可能为0,这个时候不容易处理
